model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
n
attach(tr_s_outliers)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
######### Validation Set Approch #########
train=sample(1:n,n/2)
test=(-train)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=tr_s_outliers$co2_emission
y_predict=predict(lm.fit,tr_s_outliers)
mean(((y_true-y_predict)[test])^2)
########## K-Fold Cross Validation ##########
library(boot)
glm.fit=glm(fit.linear ,data=data_complete)
cv.err=cv.glm(tr_s_high_leverage,glm.fit, K = 10)
cv.err$delta # The K-Fold Cross validation estimate for the test error is approximately  48.12944 (seed=1).
cv.error=rep(0,4)
for (i in 1:4){
glm.fit=glm(fit.poly2, data = data_complete)
cv.error[i]=cv.glm(tr_s_high_leverage,glm.fit, K=10)$delta[1]
}
cv.error
# The boot.fn() function can also be used in order to create bootstrap estimates
# for the intercept and slope terms by randomly sampling from among the observations with replacement
# We will compare the estimates obtained using the bootstrap to those obtained using the previous models
library(stringr)
indice=nrow(tr_s_outliers)
# No-transformation
set.seed (2)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level, data = tr_s_outliers,subset=index)))
}
boot.fn(tr_s_outliers, 1:indice)
s = summary(lm(model_reduced_collinearity_CM, data = tr_s_outliers))
s
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
# Log trasformation no-linear transformation
set.seed (2)
indice=nrow(tr_s)
model_not_linear_log <- lm(co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level, data = tr_s)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level,data = data,subset=index)))
}
boot.fn(tr_s, 1:indice)
boot.fn(tr_s,sample(1:indice, 36350,replace=T))
b = boot(tr_s ,boot.fn ,1000)
s = summary(lm(model_not_linear_log,data = tr_s))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the log transformation
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between log transformation Std.errors:\n",c - se,"\n")
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
# Sqrt trasformation no-linear transformation
set.seed (2)
indice=nrow(tr_s)
model_not_linear_sqrt <- lm(co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level, data = tr_s)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level,data = data,subset=index)))
}
boot.fn(tr_s, 1:indice)
boot.fn(tr_s,sample(1:indice, 36350,replace=T))
b = boot(tr_s ,boot.fn ,1000)
s = summary(lm(model_not_linear_sqrt,data = tr_s))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the log transformation
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between sqrt transformation Std.errors:\n",c - se,"\n")
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
l
l
# Polinomials-4 no-linear transformation
set.seed (2)
indice=nrow(tr_s)
model_not_linear_poly_4 <- lm(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity,4) +
fuel_type + combined_metric, data = tr_s)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric ,data = data,subset=index)))
}
boot.fn(tr_s, 1:indice)
boot.fn(tr_s,sample(1:indice, 36350,replace=T))
b = boot(tr_s ,boot.fn ,1000)
s = summary(lm(model_not_linear_poly_4,data = tr_s))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the poly-4 transformation
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between poly-4 transformation Std.errors:\n",c - se,"\n")
s
s = summary(lm(model_not_linear_sqrt,data = tr_s))
s
attach(tr_s_outliers)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
######### Validation Set Approch #########
train=sample(1:n,n/2)
test=(-train)
train
dim(train)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=tr_s_outliers$co2_emission
y_predict=predict(lm.fit,tr_s_outliers)
mean(((y_true-y_predict)[test])^2)
attach(tr_s_outliers)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
######### Validation Set Approch #########
train=sample(1:n,n/2)
test=(-train)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=tr_s_outliers$co2_emission
y_predict=predict(lm.fit,tr_s_outliers)
mean(((y_true-y_predict)[test])^2)
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_poly_2 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric)
model_not_linear_poly_3 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 3) +
fuel_type + combined_metric)
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
n = nrow(tr_s)
######### Validation Set Approch #########
train=sample(1:n,n/2)
test=(-train)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n/2)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
n = nrow(tr_s_outliers)
c=nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=tr_s_outliers$co2_emission
y_predict=predict(lm.fit,tr_s_outliers)
mean(((y_true-y_predict)[test])^2)
attach(tr_s)
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_poly_2 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric)
model_not_linear_poly_3 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 3) +
fuel_type + combined_metric)
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
attach(t_s)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
#Poly 2 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_2, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
#Poly 3 trasformation
set.seed(1)
#Poly 3 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_3, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
#Poly 4 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_4, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
#Log trasformation
set.seed(1)
lm.fit=lm(model_not_linear_log, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
# The boot.fn() function can also be used in order to create bootstrap estimates
# for the intercept and slope terms by randomly sampling from among the observations with replacement
# We will compare the estimates obtained using the bootstrap to those obtained using the previous models
library(stringr)
indice=nrow(tr_s)
# Polinomials-2 no-linear transformation
set.seed (2)
indice=nrow(tr_s)
model_not_linear_poly_2 <- lm(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric, data = tr_s)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric ,data = data,subset=index)))
}
boot.fn(tr_s, 1:indice)
boot.fn(tr_s,sample(1:indice, 36350,replace=T))
b = boot(tr_s ,boot.fn ,1000)
s = summary(lm(model_not_linear_poly_2,data = tr_s))
s = summary(lm(model_not_linear_poly_2,data = tr_s))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the poly-2 transformation
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between poly-2 transformation Std.errors:\n",c - se,"\n")
# Sqrt trasformation no-linear transformation
set.seed (2)
indice=nrow(tr_s)
model_not_linear_sqrt <- lm(co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level, data = tr_s)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level,data = data,subset=index)))
}
boot.fn(tr_s, 1:indice)
boot.fn(tr_s,sample(1:indice, 36350,replace=T))
b = boot(tr_s ,boot.fn ,1000)
s = summary(lm(model_not_linear_sqrt,data = tr_s))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the log transformation
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between sqrt transformation Std.errors:\n",c - se,"\n")
# The boot.fn() function can also be used in order to create bootstrap estimates
# for the intercept and slope terms by randomly sampling from among the observations with replacement
# We will compare the estimates obtained using the bootstrap to those obtained using the previous models
library(stringr)
indice=nrow(tr_s_outliers)
# No-transformation
set.seed (2)
boot.fn=function(data,index){
return(coef(lm(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level, data = tr_s_outliers,subset=index)))
}
boot.fn(tr_s_outliers, 1:indice)
# Boot estimate is not deterministic
boot.fn(tr_s_outliers,sample(1:n, 34375,replace=T))
boot.fn(tr_s_outliers,sample(1:n, 34375,replace=T))
# We use the boot() function to compute the standard errors
# of 1,000 bootstrap estimates for the intercept and slope terms.
b = boot(tr_s_outliers ,boot.fn ,1000)
s = summary(lm(model_reduced_collinearity_CM, data = tr_s_outliers))
# Take all std. errors of the bootstrap estimate
x <- capture.output(b)
x <- str_extract(x, "^t[0-9.]+.*$")
x <- x[!is.na(x)]
se <- as.numeric(unlist(str_extract_all(x, '[0-9.]+$')))
# Take all std. errors of the linear model
c = s$coefficients[ ,2]
c = as.numeric(c)
cat("\nDifference between no-Transformation Std.errors:\n",c - se,"\n")
# the estimated test MSE for the linear regression fit is:
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,tr_s)
mean(((y_true-y_predict)[test])^2)
#Poly 2 trasformation
set.seed(1)
attach(tr_s)
attach(t_s)
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_poly_2 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric)
model_not_linear_poly_3 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 3) +
fuel_type + combined_metric)
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=tr_s$co2_emission
# the estimated test MSE for the linear regression fit is:
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
attach(tr_s)
attach(t_s)
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_poly_2 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric)
model_not_linear_poly_3 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 3) +
fuel_type + combined_metric)
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=tr_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
attach(tr_s)
attach(t_s)
model_not_linear_sqrt <- (co2_emission ~ euro_standard + transmission_type + sqrt(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_log <- (co2_emission ~ euro_standard + transmission_type + log(engine_capacity) +
fuel_type + combined_metric  + noise_level)
model_not_linear_poly_2 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 2) +
fuel_type + combined_metric)
model_not_linear_poly_3 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 3) +
fuel_type + combined_metric)
model_not_linear_poly_4 <-(co2_emission ~ euro_standard + transmission_type + poly(engine_capacity, 4) +
fuel_type + combined_metric)
n = nrow(tr_s)
c= nrow((t_s))
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_not_linear_sqrt, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
#Poly 2 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_2, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
#Poly 3 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_3, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
View(tr_s)
#Poly 4 trasformation
set.seed(1)
lm.fit=lm(model_not_linear_poly_4, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is 33.51284 (seed=1)
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
#Log trasformation
set.seed(1)
lm.fit=lm(model_not_linear_log, data = tr_s , subset = train)
# the estimated test MSE for the linear regression fit is:
y_true=t_s$co2_emission
y_predict=predict(lm.fit,t_s)
mean(((y_true-y_predict)[test])^2)
attach(tr_s_outliers)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
c = nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
attach(tr_s_outliers)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
c = nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
mean(model_reduced_collinearity_CM$residuals)^2
mean((model_reduced_collinearity_CM$residuals))^2
mean((model_reduced_collinearity_CM$residuals)^2)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
c = nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
mean((lm.fit$residuals))^2
attach(tr_s_outliers)
attach(t_s_1)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
c = nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
attach(tr_s_outliers)
attach(t_s_1)
model_reduced_collinearity_CM <-(co2_emission ~ euro_standard + transmission_type +
fuel_type + combined_metric  + noise_level)
n = nrow(tr_s_outliers)
c = nrow(t_s_1)
######### Validation Set Approch #########
train=sample(1:n,n)
test=sample(1:c,c)
set.seed(1)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
lm.fit=lm(model_reduced_collinearity_CM, data = tr_s_outliers , subset = train)
y_true=t_s_1$co2_emission
y_predict=predict(lm.fit,t_s_1)
mean(((y_true-y_predict)[test])^2)
